#!/usr/bin/env python2
'''
Create a dat file using the function as input
'''

import numpy as np;
from cStringIO import StringIO;
def mkdat2d(F,xr=(0e-4, 35e-4, 50j),
              yr=(0e-4, 40e-4, 50j), fname=None):
    '''
    Create a two dimensional function for LSP.

    Arguments:
      F      --   A two argument, numpy-vectorized function that accepts position
                  arrays and outputs the desired function.

    Keywords:
      xr     --   Range to enter into mgrid to create the x dimension.
                  See numpy.mgrid.
      yr     --   Range to enter into mgrid to create the y dimension.
                  See numpy.mgrid.
      fname  --   Filename to write out to. If None, return as a string.

    '''

    X,Y = np.mgrid[ xr[0]:xr[1]:xr[2],
                    yr[0]:yr[1]:yr[2]]
    xlen,ylen = X.shape;
    S=F(X,Y);
    def writeout(f):
        f.write("# generated by mkdat.py\n");
        f.write("# first, dimensions\n\n");
        f.write( (("{} ")*2+'\n\n').format(xlen,ylen));
        f.write("# now, cells\n\n");
        f.write("# x:\n")
        np.savetxt(f, X[:,0], newline=' '); f.write("\n");
        f.write("# y:\n")
        np.savetxt(f, Y[0,:], newline=' '); f.write("\n");
        f.write("\n# now, the actual data\n\n")
        np.savetxt(f,S[:,:]);
        pass;
    if fname == None:
        f = StringIO();
        writeout(f);
        ret=f.getvalue();
        f.close();
        return ret;
    elif type(fname) == str:
        f = open(fname,'w');
        writeout(f);
        f.close()
    else:
        writeout(f);
    pass;

    
def mkdat(F,xr=(0e-4,35e-4, 20j),
            yr=(0e-4,40e-4, 20j),
            zr=(0e-4,40e-4, 20j),
            fname=None):
    '''

    Create a three dimensional function for LSP.

    Arguments:
      F      --   A three argument, numpy-vectorized function that accepts position
                  arrays and outputs the desired function.

    Keywords:
      xr     --   Range to enter into mgrid to create the x dimension.
                  See numpy.mgrid.
      yr     --   Range to enter into mgrid to create the y dimension.
                  See numpy.mgrid.
      zr     --   Range to enter into mgrid to create the z dimension.
                  See numpy.mgrid.
      fname  --   Filename to write out to. If None, return as a string.

    '''
    X,Y,Z = np.mgrid[ xr[0]:xr[1]:xr[2],
                      yr[0]:yr[1]:yr[2],
                      zr[0]:zr[1]:zr[2]];
    S=F(X,Y,Z);
    xlen = len(X[:,0,0]);
    ylen = len(Y[0,:,0]);
    zlen = len(Z[0,0,:]);
    def writeout(f):
        f.write("# generated by mkdat.py\n");
        f.write("# first, dimensions\n\n");
        f.write( (("{} ")*3+'\n\n').format(xlen,ylen,zlen));
        f.write("# now, cells\n\n");
        f.write("# x:\n")
        np.savetxt(f, X[:,0,0], newline=' '); f.write("\n");
        f.write("# y:\n")
        np.savetxt(f, Y[0,:,0], newline=' '); f.write("\n");
        f.write("# z:\n")
        np.savetxt(f, Z[0,0,:], newline=' '); f.write("\n");
        f.write("\n# now, the actual data\n\n")
        for i in xrange(zlen):
            np.savetxt(f,S[:,:,i]);
        pass;
    
    close = True;
    if fname == None:
        f = StringIO();
        writeout(f);
        ret=f.getvalue();
        f.close();
        return ret;
    elif type(fname) == str:
        f = open(fname,'w');
        writeout(f);
        f.close()
    else:
        writeout(f);
    pass;
unitstep = np.vectorize(lambda x: 1 if x > 0 else 0);
def mkdecay(solid, sdims, xdims, l):
    '''
    Make a one dimensional decay with solid density as a vectorized function.
    
    Arguments:
      solid   --  solid density.
      sdims   --  dimensions of the solid density as a tuple of (min,max).
      xdims   --  boundaries of the whole target as a tuple of (min, max).
                  Zeroes are appended before and after the target.
      l       --  exponential scale length.
    
    Returns:
      the created vectorized function.
    '''
    def out(x):
        if x <= xdims[0] or x >= xdims[1]:
            return 0.0;
        elif sdims[0] <= x <= sdims[1]:
            return solid;
        else:
            return np.exp(-np.abs(x-sdims[1])/l)*solid;
    return np.vectorize(out);
